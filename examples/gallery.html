<!DOCTYPE html>
<html lang="en">
	<head>
		<title>js webgl - box projected cubemap environment mapping</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="main.css">
	</head>
	<body>

		<div id="container"></div>
		<div id="info">
		Testing NFT gallery <br> Demo Scene
		</div>
		<video id="video" loop crossOrigin="anonymous" playsinline style="display:none"   muted>

				<source src="https://stream.mux.com/kOHbRiWtS9SK9d01llu1DyYsyUKePjx02xN7Ru7UR00007g/high.mp4" >
				<!--<source src="https://stream.mux.com/kEoeZ7GjCjKKpwrQTk3902Gxx6ZqLnYKdmeLvZbvfbUY/high.mp4">-->

					<source src="textures/sintel.mp4" type='video/mp4; codecs="avc1.42E01E, mp4a.40.2"'>
		</video>


		<script type="module">

			import * as THREE from '../build/three.module.js';

			import Stats from './jsm/libs/stats.module.js';

			import { GUI } from './jsm/libs/dat.gui.module.js';
			import { OrbitControls } from './jsm/controls/OrbitControls.js';
			import { RectAreaLightHelper } from './jsm/helpers/RectAreaLightHelper.js';
			import { RectAreaLightUniformsLib } from './jsm/lights/RectAreaLightUniformsLib.js';
			//import { OBJLoader } from './jsm/loaders/OBJLoader.js';

			import {EffectComposer} from './jsm/postprocessing/EffectComposer.js';
			import {RenderPass} from './jsm/postprocessing/RenderPass.js';
			import { SMAAPass } from './jsm/postprocessing/SMAAPass.js';
			import {BloomPass} from './jsm/postprocessing/BloomPass.js';
			import {FilmPass} from './jsm/postprocessing/FilmPass.js';

			// shader injection for box projected cube environment mapping
			const worldposReplace = /* glsl */`
			#define BOX_PROJECTED_ENV_MAP

			#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP )

				vec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );

				#ifdef BOX_PROJECTED_ENV_MAP

					vWorldPosition = worldPosition.xyz;

				#endif

			#endif
			`;

			const envmapPhysicalParsReplace = /* glsl */`
			#if defined( USE_ENVMAP )

				#define BOX_PROJECTED_ENV_MAP

				#ifdef BOX_PROJECTED_ENV_MAP

					uniform vec3 cubeMapSize;
					uniform vec3 cubeMapPos;
					varying vec3 vWorldPosition;

					vec3 parallaxCorrectNormal( vec3 v, vec3 cubeSize, vec3 cubePos ) {

						vec3 nDir = normalize( v );
						vec3 rbmax = ( .5 * cubeSize + cubePos - vWorldPosition ) / nDir;
						vec3 rbmin = ( -.5 * cubeSize + cubePos - vWorldPosition ) / nDir;

						vec3 rbminmax;
						rbminmax.x = ( nDir.x > 0. ) ? rbmax.x : rbmin.x;
						rbminmax.y = ( nDir.y > 0. ) ? rbmax.y : rbmin.y;
						rbminmax.z = ( nDir.z > 0. ) ? rbmax.z : rbmin.z;

						float correction = min( min( rbminmax.x, rbminmax.y ), rbminmax.z );
						vec3 boxIntersection = vWorldPosition + nDir * correction;

						return boxIntersection - cubePos;
					}

				#endif

				#ifdef ENVMAP_MODE_REFRACTION
					uniform float refractionRatio;
				#endif

				vec3 getLightProbeIndirectIrradiance( /*const in SpecularLightProbe specularLightProbe,*/ const in GeometricContext geometry, const in int maxMIPLevel ) {

					vec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );

					#ifdef ENVMAP_TYPE_CUBE

						#ifdef BOX_PROJECTED_ENV_MAP

							worldNormal = parallaxCorrectNormal( worldNormal, cubeMapSize, cubeMapPos );

						#endif

						vec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );

						// TODO: replace with properly filtered cubemaps and access the irradiance LOD level, be it the last LOD level
						// of a specular cubemap, or just the default level of a specially created irradiance cubemap.

						#ifdef TEXTURE_LOD_EXT

							vec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );

						#else

							// force the bias high to get the last LOD level as it is the most blurred.
							vec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );

						#endif

						envMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;

					#elif defined( ENVMAP_TYPE_CUBE_UV )

						vec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );

					#else

						vec4 envMapColor = vec4( 0.0 );

					#endif

					return PI * envMapColor.rgb * envMapIntensity;

				}

				// Trowbridge-Reitz distribution to Mip level, following the logic of http://casual-effects.blogspot.ca/2011/08/plausible-environment-lighting-in-two.html
				float getSpecularMIPLevel( const in float roughness, const in int maxMIPLevel ) {

					float maxMIPLevelScalar = float( maxMIPLevel );

					float sigma = PI * roughness * roughness / ( 1.0 + roughness );
					float desiredMIPLevel = maxMIPLevelScalar + log2( sigma );

					// clamp to allowable LOD ranges.
					return clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );

				}

				vec3 getLightProbeIndirectRadiance( /*const in SpecularLightProbe specularLightProbe,*/ const in vec3 viewDir, const in vec3 normal, const in float roughness, const in int maxMIPLevel ) {

					#ifdef ENVMAP_MODE_REFLECTION

						vec3 reflectVec = reflect( -viewDir, normal );

						// Mixing the reflection with the normal is more accurate and keeps rough objects from gathering light from behind their tangent plane.
						reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );

					#else

						vec3 reflectVec = refract( -viewDir, normal, refractionRatio );

					#endif

					reflectVec = inverseTransformDirection( reflectVec, viewMatrix );

					float specularMIPLevel = getSpecularMIPLevel( roughness, maxMIPLevel );

					#ifdef ENVMAP_TYPE_CUBE

						#ifdef BOX_PROJECTED_ENV_MAP
							reflectVec = parallaxCorrectNormal( reflectVec, cubeMapSize, cubeMapPos );
						#endif

						vec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );

						#ifdef TEXTURE_LOD_EXT

							vec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );

						#else

							vec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );

						#endif

						envMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;

					#elif defined( ENVMAP_TYPE_CUBE_UV )

						vec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );

					#endif

					return envMapColor.rgb * envMapIntensity;
				}
			#endif
			`;




			// scene size
			const WIDTH = window.innerWidth;
			const HEIGHT = window.innerHeight;

			// camera
			const VIEW_ANGLE = 80;
			const ASPECT = WIDTH / HEIGHT;
			const NEAR = 1;
			const FAR = 800;
			//const FOG_DENSITY = 0.013;
			const WALLMAT_ROUGHNESS = 0.4;

			let camera, cubeCamera, scene, renderer, clock;

			let cameraControls;

			let groundPlane, wallMat, ceilingMat, nftMat;
			let planeLeft,planeRight,planeBack,planeTop;

			let video, videoTex;

			let frontLight,ambLight;

			let object;

			let pixRenderTarget,pixScene,pixCam;

			let stats;

			let composer, smaapass;

			const AVG_SAMPLES = 50;
			let colorBuffer;

			init();
			animate();




		 function obc ( shader ) {

				//these parameters are for the cubeCamera texture
				shader.uniforms.cubeMapSize = { value: new THREE.Vector3( 200, 200, 200 ) };
				shader.uniforms.cubeMapPos = { value: new THREE.Vector3( 0, - 50, 0 ) };

				//replace shader chunks with box projection chunks
				shader.vertexShader = 'varying vec3 vWorldPosition;\n' + shader.vertexShader;

				shader.vertexShader = shader.vertexShader.replace(
					'#include <worldpos_vertex>',
					worldposReplace
				);

				shader.fragmentShader = shader.fragmentShader.replace(
					'#include <envmap_physical_pars_fragment>',
					envmapPhysicalParsReplace
				);

			};

			function initRt () {

				pixRenderTarget = new THREE.WebGLRenderTarget(3, 3);
				pixCam = new THREE.PerspectiveCamera(75, 1, .1, 5);
				pixCam.position.z = 2;

				pixScene = new THREE.Scene();
				pixScene.background = videoTex;

			}

			function init() {

				clock = new THREE.Clock();

				const container = document.getElementById( 'container' );

				// renderer
				renderer = new THREE.WebGLRenderer( { antialias: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( WIDTH, HEIGHT );






				renderer.outputEncoding = THREE.sRGBEncoding;

				renderer.shadowMap.enabled = true;

				container.appendChild( renderer.domElement );

				stats = new Stats();
				container.appendChild( stats.dom );

				window.addEventListener( 'resize', onWindowResize );

				// gui controls
				const gui = new GUI();
				const params = {
					'box projected': true,

				};
				const bpcemGui = gui.add( params, 'box projected' );

				bpcemGui.onChange( function ( value ) {

					if ( value ) {

						groundPlane.material = boxProjectedMat;

					} else {

						groundPlane.material = defaultMat;

					}

					render();

				} );

				// scene
				scene = new THREE.Scene();

	  		scene.fog = new THREE.Fog(0x333333, 100,300);

				// camera
				camera = new THREE.PerspectiveCamera( VIEW_ANGLE, ASPECT, NEAR, FAR );
				camera.position.set( 80, -30,0 );
				camera.rotation.set(0,0,-2);


				cameraControls = new OrbitControls( camera, renderer.domElement );
				cameraControls.maxDistance = 400;
				cameraControls.minDistance = 10;
				cameraControls.enableDamping = true;
				cameraControls.addEventListener( 'change', render );

				//cameraControls.update();

				// cube camera for environment map

			const renderTarget = new THREE.WebGLRenderTarget(1, 1);

				const cubeRenderTarget = new THREE.WebGLCubeRenderTarget( 512, {
					format: THREE.RGBFormat,
					generateMipmaps: true,
					minFilter: THREE.LinearMipmapLinearFilter
				} );
				cubeCamera = new THREE.CubeCamera( 1, 100, cubeRenderTarget );

				cubeCamera.position.set( 0, - 100, 0 );
				scene.add( cubeCamera );

				// ground floor ( with box projected environment mapping )
				const loader = new THREE.TextureLoader();
				const rMap = loader.load( 'textures/lava/lavatile.jpg' );
				rMap.wrapS = THREE.RepeatWrapping;
				rMap.wrapT = THREE.RepeatWrapping;
				rMap.repeat.set( 2, 2);

				// walls
				const diffuseTex = loader.load( 'textures/brick_diffuse.jpg', function () {
						updateCubeMap();
				} );
				const bumpTex = loader.load( 'textures/brick_bump.jpg', function () {
						updateCubeMap();

				} );

				const checkerTex = loader.load( 'textures/floors/FloorsCheckerboard_S_Diffuse.jpg', function () {


				} );
				checkerTex.wrapS = THREE.RepeatWrapping;
				checkerTex.wrapT = THREE.RepeatWrapping;
				checkerTex.repeat.set( 4, 4);



				const defaultMat = new THREE.MeshPhysicalMaterial( {
					roughness: 0,
					envMap: cubeRenderTarget.texture,
					//roughnessMap: rMap

				} );

				const boxProjectedMat = new THREE.MeshStandardMaterial( {
					color: new THREE.Color( '#ffffff' ),

					envMap: cubeRenderTarget.texture,
					roughnessMap: rMap,
					roughness:.5,
					metalness:.2,
					bumpMap: checkerTex,
					bumpScale: 0.1,
				} );

				boxProjectedMat.onBeforeCompile = obc;

				groundPlane = new THREE.Mesh( new THREE.PlaneGeometry( 300, 200, 1 ), boxProjectedMat );
				groundPlane.rotateX( - Math.PI / 2 );
				groundPlane.position.set( 0, - 49, 0 );
				scene.add( groundPlane );



				bumpTex.wrapS = THREE.RepeatWrapping;
				bumpTex.wrapT = THREE.RepeatWrapping;
				bumpTex.repeat.set( 4, 4);
				diffuseTex.wrapS = THREE.RepeatWrapping;
				diffuseTex.wrapT = THREE.RepeatWrapping;
				diffuseTex.repeat.set( 2, 2);


				video = document.getElementById( 'video' );
				video.muted = true;
				video.play();

				videoTex = new THREE.VideoTexture( video );
				videoTex.wrapS = THREE.RepeatWrapping;
				videoTex.wrapT = THREE.RepeatWrapping;
				rMap.repeat.set( 2, .2);

				initRt();


				//diffuseTex.repeat.set(2,2);
				//bumpTex.repeat.set(2,2);
				//bumpTex.RepeatWrapping

				wallMat = new THREE.MeshPhysicalMaterial( {
					//map: diffuseTex,
					bumpMap: bumpTex,
					bumpScale: 0.1,
					roughness:0,
					metalness:.2,


				} );
				ceilingMat = new THREE.MeshPhysicalMaterial( {
					metalness:0,
					color: new THREE.Color( '#ffffff' ),
					roughness: .2,

				} );





				nftMat = new THREE.MeshStandardMaterial( {
					emissiveMap : videoTex,
					emissiveIntensity: 1,
					color: 0xffffff,
					emissive: 0xffffff,

				} );



				const planeGeo = new THREE.PlaneGeometry( 300, 300 );


				planeLeft = new THREE.Mesh( planeGeo, wallMat );
				planeLeft.position.z = - 150;
				planeLeft.position.x = 0;
				planeLeft.position.y = 50;
				scene.add( planeLeft );

				planeRight = new THREE.Mesh( planeGeo, wallMat );
				planeRight.position.z = 150;
				planeRight.position.x = 0;
				planeRight.position.y = 50;
				planeRight.rotateY( Math.PI );
				scene.add( planeRight );


				planeBack = new THREE.Mesh( planeGeo, wallMat );
				planeBack.position.x = - 100;
				planeBack.position.y = 50;
				planeBack.rotateY( Math.PI / 2 );
				scene.add( planeBack );

				planeTop = new THREE.Mesh( planeGeo, ceilingMat );
				planeTop.scale.set(.95,.95,1);
				planeTop.position.x = 0;
				planeTop.position.y = 150;
				planeTop.rotateX( Math.PI / 2 );
				scene.add( planeTop );


				const planeBot = new THREE.Mesh( planeGeo, ceilingMat );
				planeBot.position.x = 0;
				planeBot.position.y = -100;
				planeBot.rotateX( Math.PI / 2 );
				planeBot.rotateY( Math.PI );
				scene.add( planeBot );



				const nftGeo = new THREE.PlaneGeometry( 100, 100 );
				const nft = new THREE.Mesh( nftGeo, nftMat );
				nft.position.set( -98, 5, 0 );
				nft.rotateY( Math.PI / 2 );
				scene.add( nft );






				const torusGeo = new THREE.TorusKnotGeometry( 5, 2, 100, 16 );
				const torusMat = new THREE.MeshPhysicalMaterial( { color: 0xffffff,roughness:1 } );
				const torusKnot = new THREE.Mesh( torusGeo, torusMat );
				torusKnot.position.y=-45;
				torusKnot.position.x=-50;
				scene.add( torusKnot );


				//lights
				const width = 100;
				const height = 100;
				const intensity = 2;

				ambLight = new THREE.AmbientLight( 0x404040, .1 ); // soft white light
				ambLight.shadowMap = true;
				scene.add(ambLight);

				RectAreaLightUniformsLib.init();

				frontLight = new THREE.RectAreaLight( 0xaaaaaa, intensity, width, height );
				frontLight.position.set( -98, 5, 0 );
				//frontLight.lookAt( 0, 5, 0 );
				frontLight.lookAt( 0, 5, 0 );
				frontLight.shadowMap = true;
				scene.add( frontLight );


				// poST PROC

				composer = new EffectComposer(renderer);
				composer.addPass(new RenderPass(scene, camera));



				const filmPass = new FilmPass(
						.34,   // noise intensity
						0,  // scanline intensity
						0,    // scanline count
						false,  // grayscale
				);
				filmPass.renderToScreen = false;

				composer.addPass(filmPass);

				const smaapass = new SMAAPass(
				window.innerWidth * renderer.getPixelRatio(),
				window.innerHeight * renderer.getPixelRatio()
			);
				composer.addPass(smaapass);

				colorBuffer = new Array();



			}

			function updateCubeMap() {

				//disable specular highlights on walls in the environment map
				wallMat.roughness = 1;

				//scene.fog.density = 0;

				groundPlane.visible = false;
				planeTop.visible = false;

				cubeCamera.position.copy( groundPlane.position );

				cubeCamera.update( renderer, scene );


				//scene.fog.density = FOG_DENSITY;
				wallMat.roughness = WALLMAT_ROUGHNESS;

				groundPlane.visible = true;
				planeTop.visible = true;


			}



			function onWindowResize() {

				const width = window.innerWidth;
				const height = window.innerHeight;

				camera.aspect = width / height;
				camera.updateProjectionMatrix();

				renderer.setSize( width, height );
				composer.setSize( width, height );

			}


			function animate() {


				requestAnimationFrame( animate );
				cameraControls.update();
				render();
				stats.update();

			}


			function rgb(r, g, b){
  			return "rgb("+r+","+g+","+b+")";
			}







			function avgColor (color) {
				colorBuffer.unshift(color);

				if (colorBuffer.length > AVG_SAMPLES) {
					colorBuffer.pop();
				}
				var avg = new Uint32Array(4);
				for (var i = 0; i<colorBuffer.length;i++)
				{
					avg[0] += colorBuffer[i][0];
					avg[1] += colorBuffer[i][1];
					avg[2] += colorBuffer[i][2];

				}
				avg[0] = avg[0]/colorBuffer.length;
				avg[1] = avg[1]/colorBuffer.length;
				avg[2] = avg[2]/colorBuffer.length;
				return avg


			}






			function render() {
				const time = clock.getElapsedTime();

				// square
				renderer.setRenderTarget(pixRenderTarget);
				renderer.render(pixScene, pixCam);
				var avg = new Uint32Array(4);
				const read = new Uint8Array( 4 );

				for (let i = 0; i<3 ;i++ ) {
					for (let j = 0; i+j<3 ;j++ ) {

						renderer.readRenderTargetPixels( pixRenderTarget, i, j, 1, 1, read );
						avg[0] += read[0];
						avg[1] += read[1];
						avg[2] += read[2];


					}
				}
				avg[0] = avg[0]/9;
				avg[1] = avg[1]/9;
				avg[2] = avg[2]/9;

				avg = avgColor(avg);


				frontLight.color.setRGB(avg[0]/255,avg[1]/255,avg[2]/255);
				ambLight.color = 	frontLight.color;
				frontLight.color.offsetHSL(0,0,.4);
				scene.fog.color =	frontLight.color;
				scene.fog.color.offsetHSL(0,0,-.2);
				//document.getElementById("info").style.color = rgb(avg[0],avg[1],avg[2]);
				//console.log(avg);
				renderer.setRenderTarget(null);

				camera.position.x += .1*Math.sin(time);
				camera.position.z += .05*Math.cos(time*.2);
				//camera.position.y += .05*Math.cos(time*.1);



				updateCubeMap();

				composer.render();
				//renderer.render( scene, camera );


				//console.log(cameraControls);


			}

		</script>
	</body>
</html>
